// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/vhdirk/gir-files.git)
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use std::fmt;

bitflags! {
    #[doc(alias = "GMimeDecryptFlags")]
    pub struct DecryptFlags: u32 {
        #[doc(alias = "GMIME_DECRYPT_NONE")]
        const NONE = ffi::GMIME_DECRYPT_NONE as u32;
        #[doc(alias = "GMIME_DECRYPT_EXPORT_SESSION_KEY")]
        const EXPORT_SESSION_KEY = ffi::GMIME_DECRYPT_EXPORT_SESSION_KEY as u32;
        #[doc(alias = "GMIME_DECRYPT_NO_VERIFY")]
        const NO_VERIFY = ffi::GMIME_DECRYPT_NO_VERIFY as u32;
        #[doc(alias = "GMIME_DECRYPT_ENABLE_KEYSERVER_LOOKUPS")]
        const ENABLE_KEYSERVER_LOOKUPS = ffi::GMIME_DECRYPT_ENABLE_KEYSERVER_LOOKUPS as u32;
        #[doc(alias = "GMIME_DECRYPT_ENABLE_ONLINE_CERTIFICATE_CHECKS")]
        const ENABLE_ONLINE_CERTIFICATE_CHECKS = ffi::GMIME_DECRYPT_ENABLE_ONLINE_CERTIFICATE_CHECKS as u32;
    }
}

impl fmt::Display for DecryptFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DecryptFlags {
    type GlibType = ffi::GMimeDecryptFlags;

    fn into_glib(self) -> ffi::GMimeDecryptFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeDecryptFlags> for DecryptFlags {
    unsafe fn from_glib(value: ffi::GMimeDecryptFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

bitflags! {
    #[doc(alias = "GMimeFilterBestFlags")]
    pub struct FilterBestFlags: u32 {
        #[doc(alias = "GMIME_FILTER_BEST_CHARSET")]
        const CHARSET = ffi::GMIME_FILTER_BEST_CHARSET as u32;
        #[doc(alias = "GMIME_FILTER_BEST_ENCODING")]
        const ENCODING = ffi::GMIME_FILTER_BEST_ENCODING as u32;
    }
}

impl fmt::Display for FilterBestFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for FilterBestFlags {
    type GlibType = ffi::GMimeFilterBestFlags;

    fn into_glib(self) -> ffi::GMimeFilterBestFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeFilterBestFlags> for FilterBestFlags {
    unsafe fn from_glib(value: ffi::GMimeFilterBestFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
    #[doc(alias = "GMimeOpenPGPState")]
    pub struct OpenPGPState: u32 {
        #[doc(alias = "GMIME_OPENPGP_NONE")]
        const NONE = ffi::GMIME_OPENPGP_NONE as u32;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_MESSAGE")]
        const BEGIN_PGP_MESSAGE = ffi::GMIME_OPENPGP_BEGIN_PGP_MESSAGE as u32;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_MESSAGE")]
        const END_PGP_MESSAGE = ffi::GMIME_OPENPGP_END_PGP_MESSAGE as u32;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_SIGNED_MESSAGE")]
        const BEGIN_PGP_SIGNED_MESSAGE = ffi::GMIME_OPENPGP_BEGIN_PGP_SIGNED_MESSAGE as u32;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_SIGNATURE")]
        const BEGIN_PGP_SIGNATURE = ffi::GMIME_OPENPGP_BEGIN_PGP_SIGNATURE as u32;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_SIGNATURE")]
        const END_PGP_SIGNATURE = ffi::GMIME_OPENPGP_END_PGP_SIGNATURE as u32;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_PUBLIC_KEY_BLOCK")]
        const BEGIN_PGP_PUBLIC_KEY_BLOCK = ffi::GMIME_OPENPGP_BEGIN_PGP_PUBLIC_KEY_BLOCK as u32;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_PUBLIC_KEY_BLOCK")]
        const END_PGP_PUBLIC_KEY_BLOCK = ffi::GMIME_OPENPGP_END_PGP_PUBLIC_KEY_BLOCK as u32;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_PRIVATE_KEY_BLOCK")]
        const BEGIN_PGP_PRIVATE_KEY_BLOCK = ffi::GMIME_OPENPGP_BEGIN_PGP_PRIVATE_KEY_BLOCK as u32;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_PRIVATE_KEY_BLOCK")]
        const END_PGP_PRIVATE_KEY_BLOCK = ffi::GMIME_OPENPGP_END_PGP_PRIVATE_KEY_BLOCK as u32;
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
impl fmt::Display for OpenPGPState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
#[doc(hidden)]
impl IntoGlib for OpenPGPState {
    type GlibType = ffi::GMimeOpenPGPState;

    fn into_glib(self) -> ffi::GMimeOpenPGPState {
        self.bits()
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
#[doc(hidden)]
impl FromGlib<ffi::GMimeOpenPGPState> for OpenPGPState {
    unsafe fn from_glib(value: ffi::GMimeOpenPGPState) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

bitflags! {
    #[doc(alias = "GMimeVerifyFlags")]
    pub struct VerifyFlags: u32 {
        #[doc(alias = "GMIME_VERIFY_NONE")]
        const NONE = ffi::GMIME_VERIFY_NONE as u32;
        #[doc(alias = "GMIME_VERIFY_ENABLE_KEYSERVER_LOOKUPS")]
        const ENABLE_KEYSERVER_LOOKUPS = ffi::GMIME_VERIFY_ENABLE_KEYSERVER_LOOKUPS as u32;
        #[doc(alias = "GMIME_VERIFY_ENABLE_ONLINE_CERTIFICATE_CHECKS")]
        const ENABLE_ONLINE_CERTIFICATE_CHECKS = ffi::GMIME_VERIFY_ENABLE_ONLINE_CERTIFICATE_CHECKS as u32;
    }
}

impl fmt::Display for VerifyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for VerifyFlags {
    type GlibType = ffi::GMimeVerifyFlags;

    fn into_glib(self) -> ffi::GMimeVerifyFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeVerifyFlags> for VerifyFlags {
    unsafe fn from_glib(value: ffi::GMimeVerifyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}
